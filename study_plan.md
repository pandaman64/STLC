# 単純型付きラムダ計算（STLC）のメタ理論学習プラン

このリポジトリでは、単純型付きラムダ計算の強正規化性を証明することを目指すのじゃ。
Leanを使って、基礎から理論を構築していくのじゃ。

## 1. 構文と変数の取り扱い

locally namelessな表現を使用して、STLCの構文を定義するのじゃ。

### キーポイント
* 型（`Ty`）は基本型と関数型から構成される：
  - 基本型：`base`など
  - 関数型：`T₁ → T₂`（型`T₁`から型`T₂`への関数）

* 項（`Term`）の種類：
  - 変数：束縛変数（de Bruijnインデックス）と自由変数
  - ラムダ抽象：`λ.t`（関数）
  - 適用：`t₁ t₂`（関数`t₁`に引数`t₂`を適用）

* locally nameless表現の利点：
  - α等価性が構文的等価性と一致
  - 変数の取り扱いが明確
  - 置換操作が単純化

- [ ] 型の定義（`Ty`）
- [ ] 項の定義（`Term`）：de Bruijnインデックスとfree variablesを区別する
- [ ] 開放操作（opening）の定義
- [ ] 閉鎖操作（closing）の定義
- [ ] ローカル閉包性（locally closed）の定義
- [ ] 自由変数集合の定義

## 2. 型付けと文脈

型付け規則と文脈の取り扱いを定義するのじゃ。

### キーポイント
* 文脈（`Context`）の役割：
  - 自由変数の型を追跡
  - 有効な型付け環境を維持

* 型付け判断の形式：`Γ ⊢ t : T`
  - `Γ`：文脈
  - `t`：項
  - `T`：型
  
* 主な型付け規則：
  - 変数規則：文脈から変数の型を取得
  - ラムダ抽象規則：関数の型付け
  - 適用規則：関数適用の型付け

- [ ] 文脈（`Context`）の定義
- [ ] 型付け判断（`has_type`）の定義
- [ ] 型付け規則の健全性の補題群
  - [ ] Weakening
  - [ ] Exchange
  - [ ] Substitution

## 3. 簡約と評価

項の簡約規則と評価戦略を定義するのじゃ。

### キーポイント
* β簡約の本質：
  - `(λ.t₁) t₂ → t₁[t₂/x]`（関数適用を値で置換）
  - 簡約の文脈（どこで簡約を許すか）

* 評価戦略の重要性：
  - 呼び名簡約（call-by-name）
  - 値呼び簡約（call-by-value）
  - 正規順序簡約（normal order）

* Church-Rosserの定理の意味：
  - 簡約の順序によらず、同じ結果に到達できる
  - 合流性（confluence）の保証

- [ ] 1ステップβ簡約（`step`）の定義
- [ ] 多ステップβ簡約（`multi_step`）の定義
- [ ] 正規形の定義
- [ ] 簡約の決定性の証明
- [ ] Church-Rosserの定理の証明

## 4. 型の保存

簡約が型を保存することを証明するのじゃ。

### キーポイント
* 型の保存定理の意味：
  - 簡約は型を壊さない
  - `Γ ⊢ t : T` かつ `t → t'` ならば `Γ ⊢ t' : T`

* 置換補題の重要性：
  - 項の置換が型付けを保存することを保証
  - β簡約の健全性の基礎

- [ ] 型の保存定理（Subject Reduction）の証明
  - [ ] 置換補題（Substitution Lemma）
  - [ ] 本体の証明

## 5. 強正規化性

すべての項が正規形に到達することを証明するのじゃ。

### キーポイント
* 強正規化性の意味：
  - すべての簡約列が有限のステップで終了
  - 無限ループの不可能性

* 論理関係の役割：
  - 型の意味論的な解釈を提供
  - 帰納法による証明を可能に

* 基本補題の重要性：
  - 論理関係が型付けと整合的であることを示す
  - 強正規化性証明の核心部分

- [ ] 論理関係（Logical Relations）の定義
- [ ] 基本補題（Fundamental Lemma）の証明
- [ ] 強正規化定理の証明

## 注意事項

* 各定義と証明では、cofinite quantificationを活用するのじゃ
* 証明は段階的に行い、各ステップでLeanが証明を受け入れることを確認するのじゃ
* 直感的な理解と形式的な証明の対応を常に意識するのじゃ

### cofinite quantificationについて
* 従来の∀∃形式の代わりに、有限個の例外を除いた∀∃形式を使用
* 帰納法による証明が容易になる
* 変数の新鮮さ（freshness）の取り扱いが簡単に

ぬしと一緒に、一歩一歩進んでいくのじゃ！ 